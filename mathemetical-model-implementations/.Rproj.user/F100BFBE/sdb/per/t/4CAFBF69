{
    "contents" : "\n\n#This Program is for feature selection\n#This File Contans all the functions used\n#Author - Prithviraj Chaudhuri\n\n\n#Helper Function to print a value\n\n\n\n#Function to read Data\nreadData <- function(NMIfilename, isHeader){\n  data <- read.table(NMIfilename, header=isHeader)\n  print(\"Data Read\")\n  flush.console()\n  return(data)\n}\n\n\n\n\n#Function to get MI from CSV Data\n#getNMI <- funtion(CSVDataMatrix){\n#  NMIDataMatrix <- makemim(CSVDataMatrix)\n#  return(NMIDataMatrix)\n#}\n\n\n\n\n#function to scale the CSV Data\nscaleing <- function(CSVDataMatrix){\n  \n  numOfNodes <- ncol(CSVDataMatrix)\n  numOfSamples <- nrow(CSVDataMatrix)\n  \n  minScaledVal <- 0\n  maxScaledVal <- 1\n  minVal <- 0\n  maxVal <- 0\n  scaledCsvDataMatrix <- matrix( c(0), nrow = numOfSamples, ncol = numOfNodes) \n  \n  for(j in 1:numOfNodes){\n    \n    minVal <- sapply(CSVDataMatrix[j], min, na.rm = TRUE)\n    maxVal <- sapply(CSVDataMatrix[j], max, na.rm = TRUE)\n    \n    for(i in 1:numOfSamples){\n      scaledCsvDataMatrix[i,j] <- ((CSVDataMatrix[i,j]-minVal)/(maxVal-minVal))*(maxScaledVal-minScaledVal)+minScaledVal\n    }\n  }\n  return(scaledCsvDataMatrix)\n}\n\n\n\n\n\n\n#Funtion to get mean of a vector\ngetMean <- function(scaledCsvDataMatrix, col){\n  \n  numOfSamples <- nrow(scaledCsvDataMatrix)\n  \n  sum <- 0\n  for(i in 1:numOfSamples){\n    sum <- sum + scaledCsvDataMatrix[i,col]\n  }\n  mean <- sum/numOfSamples\n  return(mean)\n}\n\n\n\n\n\n\n#Function to calculate the variance of the scaled matrix\ngetVariance <- function(scaledCsvDataMatrix){\n  \n  numOfNodes <- ncol(scaledCsvDataMatrix)\n  numOfSamples <- nrow(scaledCsvDataMatrix)\n  \n  varArray <- matrix( c(0), nrow = 1, ncol = numOfNodes) \n  \n  for(j in 1:numOfNodes){\n    sum <- 0\n    for(i in 1:numOfSamples){\n      sum <- sum + ((scaledCsvDataMatrix[i,j]-getMean(scaledCsvDataMatrix, j))*(scaledCsvDataMatrix[i,j]-getMean(scaledCsvDataMatrix, j)))\n    }\n    varArray[j] <- sum/(numOfSamples-1)\n  }\n  return(varArray)\n}\n\n\n\n\n\n\n#Function to compute density of the Feature matrix\ncomputeDensity <- function(NMIDataMatrix, isSelected){\n  \n  numOfNodes <- ncol(NMIDataMatrix)\n  \n  numNodesInducedSet <- 0\n  sumWeights <- 0\n  \n  for(i in 1:numOfNodes){\n    if(isSelected[i] == 0){\n      numNodesInducedSet <- numNodesInducedSet+1\n    }\n    for(j in i:numOfNodes){\n      if(isSelected[i]==0 && isSelected[j]==0 && NMIDataMatrix[i,j]<=1.00){ #if mi not normalized then keep threshold high\n        sumWeights <- sumWeights + NMIDataMatrix[i,j]\n      }\n    }\n  }\n  \n  density <- sumWeights/numNodesInducedSet\n  return(density)\n}\n\n\n\n\n\n#Function to compute induced degree\ncomputeInducedDegree <- function(NMIDataMatrix, isSelected){\n  \n  numOfNodes <- ncol(NMIDataMatrix)\n  inducedDegree <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  \n  sumDegreeWeights <- 0\n  numInducedNodes <- 1\n  \n  for(i in 1:numOfNodes){\n    if (isSelected[i] == 0){\n      sumDegreeWeights <- 0\n      for(j in 1:numOfNodes){\n        if(isSelected[j] == 0 && i!=j && NMIDataMatrix[i,j]<=1.00){ #threshold to be changed as above\n          sumDegreeWeights <- sumDegreeWeights + NMIDataMatrix[i,j]\n          numInducedNodes <- numInducedNodes+1\n          print(paste(\"sum degree weights = \", sumDegreeWeights))\n        }\n      }\n      inducedDegree[i] <- sumDegreeWeights\n    }else{\n      print(0)\n      inducedDegree[i] <- 0\n    }  \n  }\n  \n  return(inducedDegree)\n}\n\n\n\n\n#Function to Compute Ranking (This function needs to be modified Later)\ncomputeRanking <- function(inducedDegree, isShortListed, numOfNodes, rank){\n  \n  isToBeChecked <- matrix( c(0), nrow = 1, ncol = numOfNodes) \n  sizeCheckList <- 0\n  r <- 0\n  bestIndex <- 0\n  \n  for(i in 1:numOfNodes){\n    if(isShortListed[i] == 1){\n      isToBeChecked[i] <- 1\n      sizeCheckList <- sizeCheckList +1\n    }\n  }\n  \n  for(i in 1:sizeCheckList){\n    bestValue <- (-9999)\n    for(j in 1:numOfNodes){\n      if(isToBeChecked[j]==1){\n        if(inducedDegree[j] > bestValue){\n          print(paste(\"Before swapping rank[i] = \", rank[i] ,\" and rank[j] = \", rank[j]))\n          bestIndex <- j\n          bestValue <- inducedDegree[j]\n          print(paste(\"After swapping rank[i] = \", rank[i],\" and rank[j] = \", rank[j]))\n        }\n      }\n    }\n    r <- r+1\n    rank[bestIndex] <- r\n    isToBeChecked[bestIndex] <- 0\n  }\n  return(rank)\n}\n\n\n\n#Function to find the combinations\ngetComb <- function(n, t){\n  val <- factorial(n)/(factorial(n-t)*factorial(t))\n  return(val)\n}\n\n\n\n\n\n#function to find the cluster index\nfindingClusterIndex <- function(NMIDataMatrix, isSelected, clusterIndex){\n  \n  numOfNodes <- ncol(NMIDataMatrix)\n  \n  index <- 0\n  for(i in 1:numOfNodes){\n    if(isSelected[i] == 0){\n      clusterIndex[i] <- index\n      index <- index + 1\n    }\n  }\n  \n  print(paste(\"Index = \", index))\n  \n  for(i in 1:numOfNodes){\n    if(isSelected[i] == 1){\n      maxSimVal <- 0\n      for(j in 1:numOfNodes){\n        if(i!=j && isSelected[j] == 0){\n          if(NMIDataMatrix[i,j] > maxSimVal){\n            maxSimVal <- NMIDataMatrix[i,j]\n            clusterIndex[i] <- clusterIndex[j]\n          }\n        }\n      }\n    } \n  }\n  return(clusterIndex)\n}\n\n\n#Function to obtain prototyping feature\nobtainPrototypeFeature <- function(NMIDataMatrix, scaledCsvDataMatrix, isSelected, clusterIndex, K){\n  \n  \n  \n  numOfNodes <- ncol(scaledCsvDataMatrix)\n  numOfSamples <- nrow(scaledCsvDataMatrix)\n  \n  simDegree <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  clusterPrototypeFeature <- matrix( c(0), nrow = 1, ncol = K )\n  numClusterEle <- matrix( c(0), nrow = 1, ncol = K )\n  \n  for(i in 1:numOfNodes){\n    numClusterEle[clusterIndex[i]+1] <- numClusterEle[clusterIndex[i]+1] + 1\n  }\n  \n  for(i in 1:numOfNodes){\n    for(j in 1:numOfNodes){\n      if(i != j && clusterIndex[i] == clusterIndex[j] ){\n        simDegree[i] <- simDegree[i] + NMIDataMatrix[i,j]\n      }\n    }\n  }\n  \n  print(\"Cluster Degree value of each feature\")\n  \n  for(i in 1:numOfNodes){\n    print(simDegree[i])\n  }\n  \n  \n  print(\"Number of cluster elements\")\n  for(i in 1:K){\n    print(numClusterEle[i])\n  }\n  \n  print(\"Cluster Prototype Features\")\n  \n  for(index in 1:K){\n    \n    maxVal <- 0\n    minVal <- 0\n    \n    for(j in 1:numOfNodes){\n      if(clusterIndex[j] == index-1){\n        if(simDegree[j] == 1){\n          clusterPrototypeFeature[index] <- (j-1)\n          break\n        }\n        \n        if(varArray[j] > maxVal){\n          clusterPrototypeFeature[index] <- (j-1)\n          maxVal <- varArray[j]\n        }\n      }\n    }\n    print(clusterPrototypeFeature[index])\n  }\n  \n  clusterNodes <- matrix(c(0), nrow=noOfClusters, ncol=numOfNodes)\n  \n  for(index in 1:K){\n    print(paste(\"Cluster with index \",index,\" has the following features\"))\n    for(j in 1:numOfNodes){\n      if(clusterIndex[j]==index-1){\n        clusterNodes[index,j] <- j\n        print(j)\n      }  \n    }\n    \n  }\n  \n  assign(\"clusterNodes\", clusterNodes, envir = .GlobalEnv)\n  \n  print(paste(\"Var is \", varArray[1]))\n  \n  for(j in 1:numOfNodes){\n    isSelected[j] <- 1\n    for(index in 1:K){\n      if(clusterPrototypeFeature[index]==j-1){\n        isSelected[j] <- 0\n        break\n      }  \n    }\n  }\n  return(isSelected)\n}\n\n\n\n\n#Function to compute the density variation sequences (Needs some serious debugging)\ncomputeDensityVarSeq <- function(NMIDataMatrix, scaledCsvDataMatrix, varArray, noOfClusters){\n  \n  K <- noOfClusters\n  numOfNodes <- ncol(scaledCsvDataMatrix)\n  numOfSamples <- nrow(scaledCsvDataMatrix)\n  print(paste(numOfNodes,numOfSamples))\n  \n  isSelected <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  isCurrentlyDiscarded <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  isShortListed <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  isOptimal <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  inducedDegree <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  rank <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  clusterIndex <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  oldClusterIndex <- matrix( c(0), nrow = 1, ncol = numOfNodes )\n  \n  \n  currentDensity <- computeDensity(NMIDataMatrix, isSelected)\n  optimalDensity <- currentDensity\n  \n  clusterLoop <- 0\n  optimalNodeCount <- 0\n  \n  print(paste(\"Optimal Density = \", optimalDensity))\n  \n  while(1){\n    \n    nodeCount <- 0\n    \n    for(i in 1:numOfNodes){\n      if(isSelected[i]==0){\n        nodeCount <- nodeCount + 1\n      }\n      rank[i] <- 999999\n    }\n    \n    print(\"Starting the next iteration\")\n    print(paste(\"Total number of non-selected nodes is\",nodeCount))\n    \n    if(nodeCount==0 || nodeCount <= K){\n      break\n    }\n    \n   \n    inducedDegree <- computeInducedDegree (NMIDataMatrix, isSelected)\n   \n    \n    \n    noShortListed <- 0\n    for(i in 1:numOfNodes){\n      if(isSelected[i] == 0){\n        if(inducedDegree[i] >= 2*optimalDensity){\n          isShortListed[i] <- 1\n          noShortListed <- noShortListed + 1\n        }else{\n          isShortListed[i] <- 0\n        }\n      }else{\n        isShortListed[i] <-0\n      }\n    }\n    \n    if(noShortListed > 0){\n      print(paste(\"There is \",noShortListed,\" shortlisted Candidates \" ))\n    }\n    \n    rankLimit <- 2\n    \n    print(paste(\"The rank Limit is \", rankLimit))\n    \n    if(rankLimit > noShortListed){\n      rankLimit <- 0.5*noShortListed\n    }\n    \n    if(noShortListed == 1){\n      rankLimit <- 1\n    }else if(noShortListed == 0){\n      break\n    }\n    \n    rank <- computeRanking(inducedDegree, isShortListed, numOfNodes, rank)\n    \n    for(i in 1:numOfNodes){\n      isCurrentlyDiscarded[i] <- 0\n      if(isShortListed[i] == 1){\n        print(\"Short Listed\")\n        if(rank[i] < rankLimit){\n          print(paste(\"Second rankLimit is \", rankLimit))\n          isSelected[i] <- 1\n          isCurrentlyDiscarded[i] <- 1\n        }\n      }\n    }\n    \n    currentDensity <- computeDensity(NMIDataMatrix, isSelected)\n    \n    density <- 0\n    noNodes <- 0\n    sumWeight <- 0\n    print(paste(\"Current Density is \", currentDensity))\n    \n    for(i in 1:numOfNodes){\n      if(isSelected[i] == 1 && isCurrentlyDiscarded[i] == 0){\n        noNodes <- 0\n        sumWeight <- 0\n        isSelected[i] <- 0\n        \n        for(j in 1:numOfNodes){\n          if(isSelected[j]==0 && j!=i && (NMIDataMatrix[i,j]<=1.00)){\n            noNodes <- noNodes + 1\n            sumWeight <- sumWeight + NMIDataMatrix[i,j]\n          }\n        }\n        \n        density <- (currentDensity*noNodes+sumWeight)/(noNodes+1)\n        \n        if(density < currentDensity){\n          print(paste(\"One node with id \",i+1,\" is being readded\"))\n          currentDensity <- density\n        }else{\n          isSelected[i] <- 1\n        }\n      }\n    }\n    \n    if(currentDensity <= optimalDensity){\n      optimalDensity <- currentDensity\n      optimalNodeCount <- 0\n      \n      for (i in 1:numOfNodes){\n        isOptimal[i]= 1-isSelected[i];\n      }\n      \n      for(i in 1:numOfNodes){\n        if(isOptimal[i] == 1){\n          optimalNodeCount <- optimalNodeCount + 1\n          print(i+1)\n        }\n      }\n      print(\"\")\n    }\n    print(paste(\"Optimal Node Count is \", optimalNodeCount))\n    print(paste(\"Optimal Density is \", optimalDensity))\n    \n    if(optimalNodeCount==K)\n      break\n  }\n  \n  \n  while(1){\n    \n    clusterIndex <- findingClusterIndex(NMIDataMatrix, isSelected, clusterIndex)\n    \n    print(\"Cluster Index\")\n    for(i in 1:numOfNodes){\n      print(clusterIndex[i])\n    }\n    \n    continueFlag <- 0\n    for(i in 1:numOfNodes){\n      if(clusterIndex[i] != oldClusterIndex[i]){\n        continueFlag <- 1\n        print(\"First Break\")\n        break\n      }\n    }\n    \n    if(continueFlag == 0){\n      print(\"Second Break\")\n      break\n    }\n    \n    for(i in 1:numOfNodes){\n      oldClusterIndex[i] <- clusterIndex[i]\n    }\n    isSelected <- obtainPrototypeFeature(NMIDataMatrix, scaledCsvDataMatrix, isSelected, clusterIndex, K)\n    clusterLoop <-clusterLoop +1\n    print(paste(\" cluster loop = \", clusterLoop))\n  }\n}\n\n",
    "created" : 1443973212916.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3480999099",
    "id" : "4CAFBF69",
    "lastKnownWriteTime" : 1447054925,
    "path" : "C:/Users/prithviraj/Desktop/final-year-project/mathemetical-model-implementations/functions.R",
    "project_path" : "functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}